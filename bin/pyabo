#!/usr/bin/env python2.7
# vim: sw=4 sts=4 et fileencoding=utf8 nomod
# Copyright 2013 Andrew Bettison

'''Usage:
    pyabo chart [-fvD] [AL|PL|EQ]
    pyabo index [-fD]
    pyabo acc [-bfwWD] [--remove=ACC...] [--width=COLUMNS] [--wide] <account> [<period>...]
    pyabo journal [-fwWD] [--remove=ACC...] [--width=COLUMNS] [<period>...]
    pyabo balance [-faWD] [--remove=ACC...] [--width=COLUMNS] [<when>...]
    pyabo profloss [-faWD] [--remove=ACC...] [--width=COLUMNS] [--tag=TAG] [<period>...]
    pyabo compa <command> <word> <preword>
    pyabo -h | --help
    pyabo --version
Options:
    -h --help               Show this message
    --version               Show version and exit
    -D --debug              Log debug on stderr
    -f --force              Force re-population of transaction cache
    --tag=TAG               Only show tagged accounts
    -w --wrap               Wrap long lines
    --width=COLUMNS         Maximum line length (default from 'COLUMNS' env var)
    -W --wide               Wide output, no maximum width
    -a --all                Show all accounts
    -b --bring-forward      Bring balance of previous transactions forward
    -v --verbose            Show more information
    -r --remove=ACC         Remove account ACC
'''

import sys
import locale
import codecs
import os.path
import textwrap
import datetime
from itertools import chain
import logging

try:
    import docopt
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), '..', 'lib', 'docopt'))
    import docopt

try:
    import abo.journal
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), '..', 'lib'))
    import abo.journal
import abo.config
import abo.period
import abo.transaction
from abo.transaction import sign
import abo.balance
import abo.cache
from abo.types import struct

def main():
    logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
    locale.setlocale(locale.LC_ALL, '')
    lang, enc = locale.getlocale()
    output_encoding = enc
    opts = docopt.docopt(__doc__, version='0.1')
    if opts['acc']:
        func = cmd_acc
    elif opts['journal']:
        func = cmd_journal
    elif opts['chart']:
        func = cmd_chart
    elif opts['index']:
        func = cmd_index
    elif opts['profloss']:
        func = cmd_profloss
    elif opts['balance']:
        func = cmd_balance
    elif opts['compa']:
        func = cmd_compa
    else:
        assert False, 'unknown command'
    if not opts['--debug']:
        logging.disable(logging.DEBUG)
    try:
        config = abo.config.Config().load(opts)
    except abo.config.ConfigException, e:
        fatal(unicode(e).encode(output_encoding))
    try:
        for line in func(config, opts):
            print line.encode(output_encoding)
    except InvalidArg, e:
        fatal(unicode(e).encode(output_encoding))
    sys.exit(0)

_chart_cache = None
_transaction_caches = None

def chart_cache(config, opts):
    global _chart_cache
    if _chart_cache is None:
        def compile_chart():
            chart = abo.account.Chart.from_file(file(config.chart_file_path))
            for tc in transaction_caches(chart, config, opts):
                tc.get()
            return chart
        _chart_cache = abo.cache.FileCache(config, config.chart_file_path, compile_chart, config.input_file_paths, force=opts['--force'])
    return _chart_cache

def transaction_caches(chart, config, opts):
    global _transaction_caches
    if _transaction_caches is None:
        _transaction_caches = []
        for path in config.input_file_paths:
            _transaction_caches.append(abo.cache.TransactionCache(config, path, abo.journal.Journal(config, file(path), chart=chart), [config.chart_file_path], force=opts['--force']))
    return _transaction_caches

def get_chart(config, opts):
    return chart_cache(config, opts).get()

def get_transactions(chart, config, opts):
    transactions = []
    for cache in transaction_caches(chart, config, opts):
        transactions += cache.transactions()
    transactions.sort(key=lambda t: (t.date, t.who or '', t.what or '', -t.amount()))
    if opts['--remove']:
        for account in opts['--remove']:
            acc = chart[account]
            transactions = remove_account(chart, lambda a: a in acc, transactions)
    return transactions

def cmd_journal(config, opts):
    chart = get_chart(config, opts)
    range, bf, transactions = filter_period(chart, get_transactions(chart, config, opts), opts)
    dw = 11
    bw = config.balance_column_width()
    aw = max(len(a.shortname()) for a in chart.accounts())
    if config.output_width():
        width = max(50, config.output_width())
        aw = min(15, aw)
        pw = max(1, width - (dw + 2 + 1 + bw + 1 + 2 + 1 + aw))
    else:
        pw = 35
        width = dw + 2 + pw + 1 + bw + 1 + 2 + 1 + aw
    fmt = u'%-{dw}.{dw}s  %-{pw}.{pw}s %{bw}s %-2.2s %-.{aw}s'.format(**locals())
    yield 'JOURNAL OF TRANSACTIONS'.center(width)
    yield range_line(range).center(width)
    yield ''
    yield fmt % ('Date', 'Particulars', 'Amount', 'DC', 'Account')
    yield fmt % ('-' * dw, '-' * pw, '-' * bw, '--', '-' * aw)
    def entry_fields(e):
        return (config.format_money(abs(e.amount)), ('db' if e.amount < 0 else 'cr'), chart[e.account].shortname())
    if bf:
        for e in bf.entries():
            yield fmt % (('',
                'Brought forward' + (' due ' + e.cdate.strftime(ur'%-d-%b-%Y') if e.cdate else ''),)
                + entry_fields(e))
    for t in transactions:
        desc = textwrap.wrap(t.description(), width=pw)
        entries = list(t.entries)
        yield fmt % ((t.date.strftime(ur'%_d-%b-%Y'), desc.pop(0)) + entry_fields(entries.pop(0)))
        while entries:
            yield fmt % (('', desc.pop(0) if desc else u'') + (entry_fields(entries.pop(0)) if entries else ('', '', '')))
        if opts['--wrap']:
            while desc:
                yield fmt % ('', desc.pop(0), '', '', '')
    yield fmt % ('-' * dw, '-' * pw, '-' * bw, '--', '-' * aw)

def cmd_chart(config, opts):
    typesel = (opts['AL'] or '').upper()
    if typesel == '':
        pred = lambda a: True
    else:
        try:
            atype = abo.account.tag_to_atype[typesel]
            pred = lambda a: a.atype == atype
        except KeyError:
            raise InvalidArg('invalid argument: %r' % (typesel,))
    for account in get_chart(config, opts).accounts():
        if pred(account):
            line = [unicode(account)]
            if opts['--verbose']:
                if account.label:
                    line.append('[%s]' % (account.label,))
                if account.atype and not (account.parent and account.parent.atype == account.atype):
                    line.append('=%s' % (abo.account.atype_to_tag[account.atype]))

            yield ' '.join(line)

def cmd_index(config, opts):
    chart = get_chart(config, opts)
    return sorted(chart.iterkeys())

def cmd_compa(config, opts):
    word, preword = opts['<word>'], opts['<preword>']
    #print >>sys.stderr, 'word=%r preword=%r' % (word, preword),
    chart = get_chart(config, opts)
    keys = set()
    if preword not in ('--width',):
        for key in chart.iterkeys():
            if key.startswith(word) and len(key) > len(word):
                comp = key[len(word):]
                end = ''
                if ':' in comp:
                    comp = comp.split(':', 1)[0] + ':'
                else:
                    end = ' '
                keys.add(shell_quote(word + comp) + end)
    keys = sorted(keys)
    #print >>sys.stderr, ' keys=%r' % keys,
    return keys

def shell_quote(text):
    return (text.replace('\\', '\\\\')
                .replace('"', '\\"')
                .replace("'", "\\'")
                .replace('$', '\\$')
                .replace('`', '\\`')
                .replace(' ', '\\ '))

def cmd_acc(config, opts):
    chart = get_chart(config, opts)
    account = chart[opts['<account>']]
    range, bf, transactions = filter_period(chart, get_transactions(chart, config, opts), opts)
    dw = 11
    mw = config.money_column_width()
    bw = config.balance_column_width()
    if config.output_width():
        width = max(50, config.output_width())
        pw = max(1, width - (dw + 2 + 2 * (mw + 1) + 1 + bw))
    else:
        pw = 35
        width = dw + 2 + pw + 2 * (mw + 1) + 1 + bw
    fmt = u'%-{dw}.{dw}s  %-{pw}.{pw}s %{mw}s %{mw}s %{bw}s'.format(**locals())
    yield 'STATEMENT OF ACCOUNT'.center(width)
    yield range_line(range).center(width)
    yield ''
    yield fmt % ('Date', 'Particulars', 'Debit', 'Credit', 'Balance')
    yield fmt % ('-' * dw, '-' * pw, '-' * mw, '-' * mw, '-' * bw)
    balance = 0
    totdb = 0
    totcr = 0
    if opts['--bring-forward'] and bf:
        for e in bf.entries():
            if chart[e.account] in account:
                balance += e.amount
                yield fmt % ('', 'Brought forward' + (' due ' + e.cdate.strftime(ur'%-d-%b-%Y') if e.cdate else ''),
                        config.format_money(-e.amount) if e.amount < 0 else '',
                        config.format_money(e.amount) if e.amount > 0 else '',
                        config.format_money(balance))
    for t in transactions:
        for e in t.entries:
            if chart[e.account] in account:
                balance += e.amount
                if e.amount < 0:
                    totdb += e.amount
                elif e.amount > 0:
                    totcr += e.amount
                desc = textwrap.wrap(e.description(), width=pw)
                yield fmt % (e.transaction.date.strftime(ur'%_d-%b-%Y'),
                        desc.pop(0),
                        config.format_money(-e.amount) if e.amount < 0 else '',
                        config.format_money(e.amount) if e.amount > 0 else '',
                        config.format_money(balance))
                if opts['--wrap']:
                    while desc:
                        yield fmt % ('', desc.pop(0), '', '', '')
    yield fmt % ('-' * dw, '-' * pw, '-' * mw, '-' * mw, '-' * bw)
    yield fmt % ('', 'Totals for period',
            config.format_money(-totdb),
            config.format_money(totcr),
            '')
    yield fmt % ('', 'Balance', '', '', config.format_money(balance))

def cmd_profloss(config, opts):
    acc_pred = parse_account_predicate(opts)
    periods = parse_periods(opts)
    chart = get_chart(config, opts)
    transactions = get_transactions(chart, config, opts)
    sections = []
    all_accounts = set()
    for pred in ((lambda a, c, m: m > 0), (lambda a, c, m: m < 0)):
        bpred = lambda a, c, m: a.atype == abo.account.AccountType.ProfitLoss and (opts['--all'] or m) and acc_pred(a) and pred(a, c, m)
        balances = [abo.balance.Balance(transactions, abo.balance.Range(p[0], p[1] + datetime.timedelta(1)), chart=chart, pred=bpred) for p in periods]
        accounts = reduce(lambda x, y: x | y, (b.accounts for b in balances))
        sections.append(struct(balances=balances, accounts=accounts))
        all_accounts.update(accounts)
    bw = config.balance_column_width()
    aw = max(chain([10], (len(unicode(a)) for a in all_accounts)))
    width = (bw + 1) * len(balances) +  1 + aw
    if config.output_width() and width > config.output_width():
        aw = max(10, config.output_width() - ((bw + 1) * len(balances) + 1))
    fmt = (u'%{bw}s ' * len(balances) + u' %.{aw}s').format(**locals())
    yield 'PROFIT LOSS STATEMENT'.center(width)
    line = []
    for balance in balances:
        line.append(balance.date_range.start.strftime(ur'%_d-%b-%Y') if balance.date_range.start else '')
    line.append('')
    yield fmt % tuple(line)
    line = []
    for balance in balances:
        line.append((balance.date_range.end - datetime.timedelta(1)).strftime(ur'%_d-%b-%Y') if balance.date_range.end else '')
    line.append('Account')
    yield fmt % tuple(line)
    yield fmt % (('-' * bw,) * len(balances) + ('-' * aw,))
    for section in sections:
        for account in sorted(section.accounts, key=unicode):
            line = []
            for balance in section.balances:
                line.append(config.format_money(balance.balance(account)))
            line.append(unicode(account))
            yield fmt % tuple(line)
        yield fmt % (('-' * bw,) * len(section.balances) + ('-' * aw,))

def cmd_balance(config, opts):
    chart = get_chart(config, opts)
    all_transactions = get_transactions(chart, config, opts)
    when, balance, transactions = filter_at(chart, all_transactions, opts)
    bw = config.balance_column_width()
    aw = max(len(unicode(a)) for a in chart.accounts())
    width = bw + 2 + aw
    if config.output_width() and width > config.output_width():
        aw = max(10, config.output_width() - (bw + 2))
    fmt = u'%{bw}s  %.{aw}s'.format(**locals())
    yield 'ACCOUNT BALANCES'.center(width)
    yield when.strftime(ur'%_d-%b-%Y').center(width)
    yield ''
    yield fmt % ('Balance', 'Account')
    yield fmt % ('-' * bw, '-' * aw)
    for account in balance.accounts:
        bal = balance.balance(account)
        if bal or opts['--all']:
            yield fmt % (config.format_money(bal), unicode(account))
    yield fmt % ('-' * bw, '-' * aw)

def remove_account(chart, pred, transactions):
    from collections import defaultdict
    logging.debug("remove")
    queues = defaultdict(list)
    todo = list(transactions)
    done = []
    while todo:
        t = todo.pop(0)
        remove = defaultdict(lambda: struct(amount=0, entries=[]))
        keep = []
        keep_total = 0
        for e in t.entries:
            if pred(chart[e.account]):
                s = sign(e.amount)
                remove[s].amount += e.amount
                remove[s].entries.append(e)
            else:
                keep.append(e)
                keep_total += e.amount
        # If the transaction involves exclusively removed accounts, then remove
        # the entire transaction.
        if not keep:
            continue
        # Cancel removed entries against each other, leaving removable entries
        # with only one sign.
        if remove[1].entries and remove[-1].entries:
            remove_amount = remove[-1].amount + remove[1].amount
            assert remove_amount == -keep_total
            if remove_amount == 0:
                assert keep
                assert keep_total == 0
                done.append(t.replace(entries=keep))
                logging.debug("   done %r" % (done[-1],))
                continue
            else:
                s = sign(remove_amount)
                e1, e2 = abo.transaction._divide_entries(remove[s].entries, -remove[-s].amount)
                assert e1
                assert e2
                assert sum(e.amount for e in e1) == -remove[-s].amount
                assert sum(e.amount for e in e2) == remove_amount
                remove = e2
                t = t.replace(entries= chain(e2 + keep))
        elif remove[1].entries:
            remove_amount = remove[1].amount
            remove = remove[1].entries
        elif remove[-1].entries:
            remove_amount = remove[-1].amount
            remove = remove[-1].entries
        else:
            done.append(t)
            logging.debug("   done %r" % (done[-1],))
            continue
        logging.debug("remove %u entries from t = %s %s" % (len(remove), t.amount(), t.date))
        while remove:
            account = remove[0].account
            entries = [e for e in remove if e.account == account]
            assert entries
            remove = [e for e in remove if e.account != account]
            assert t is not None
            assert entries == [e for e in t.entries if e.account == account]
            amount = sum(e.amount for e in entries)
            assert sign(amount) == sign(remove_amount)
            assert abs(amount) <= abs(remove_amount)
            # If this account is not the only one to be removed from this
            # transaction, then split this transaction into one containing only
            # this account and a remainder containg all the other removable
            # accounts.
            if remove:
                k1, k2 = abo.transaction._divide_entries(keep, -amount)
                assert sum(e.amount for e in k1) == -amount
                assert k2
                tr = t.replace(entries= chain(entries + k1))
                t = t.replace(entries= chain(remove + k2))
            else:
                tr, t = t, None
            assert tr is not None
            queue = queues[account]
            if not queue or sign(queue[0].amount) == sign(amount):
                logging.debug("   enqueue %s" % (account,))
                queue.append(struct(amount=amount, transaction=tr)) # TODO sort by due date
            else:
                while queue and abs(queue[0].amount) <= abs(amount):
                    logging.debug("   amount=%s queue[0].amount=%s" % (amount, queue[0].amount))
                    assert sign(queue[0].amount) != sign(amount)
                    if abs(queue[0].amount) == abs(amount):
                        k1, keep = keep, None
                    else:
                        k1, k2 = abo.transaction._divide_entries(keep, queue[0].amount)
                        assert k1
                        assert k2
                        assert len(k1) <= len(keep)
                        keep = k2
                        keep_total = sum(e.amount for e in keep)
                    assert sum(e.amount for e in k1) == queue[0].amount
                    done.append(tr.replace(entries= [e for e in chain(k1, queue[0].transaction.entries) if e.account != account]))
                    logging.debug("   done %r" % (done[-1],))
                    amount += queue[0].amount
                    e1, e2 = abo.transaction._divide_entries(entries, -queue[0].amount)
                    assert sum(e.amount for e in e1) == -queue[0].amount
                    assert sum(e.amount for e in e2) == amount
                    entries = e2
                    queue.pop(0)
                if amount and queue:
                    assert entries
                    assert keep
                    logging.debug("   amount=%s queue[0].amount=%s" % (amount, queue[0].amount))
                    assert abs(amount) < abs(queue[0].amount)
                    assert sign(amount) != sign(queue[0].amount)
                    assert abs(amount) <= abs(keep_total)
                    if keep_total == -amount:
                        k1, keep = keep, None
                    else:
                        k1, k2 = abo.transaction._divide_entries(keep, -amount)
                        assert k1
                        assert k2
                        assert len(k1) <= len(keep)
                        keep = k2
                    assert sum(e.amount for e in k1) == -amount
                    qa = [e for e in queue[0].transaction.entries if e.account == account]
                    qo = [e for e in queue[0].transaction.entries if e.account != account]
                    assert sum(e.amount for e in qa) == queue[0].amount
                    assert sum(e.amount for e in qo) == -queue[0].amount
                    qa1, qa2 = abo.transaction._divide_entries(qa, -amount)
                    qo1, qo2 = abo.transaction._divide_entries(qo, amount)
                    assert sum(e.amount for e in qa1) == -amount
                    assert sum(e.amount for e in qo1) == amount
                    done.append(tr.replace(entries= list(chain(k1, qo1))))
                    logging.debug("   done %r" % (done[-1],))
                    queue[0].amount += amount
                    queue[0].transaction = tr.replace(entries= list(chain(qa2, qo2)))
    return done

def parse_account_predicate(opts):
    tag = opts['--tag']
    if not tag:
        return lambda a: True
    if tag.startswith('!'):
        return lambda a: tag[1:] not in a.tags
    return lambda a: tag in a.tags

def parse_periods(opts):
    brought_forward = None
    if opts['<period>']:
        periods = abo.period.parse_periods(opts['<period>'])
    else:
        periods = [(None, None)]
    return [(p[0], p[1] if p[1] is not None else datetime.date.today()) for p in periods]

def parse_range(words):
    periods = abo.period.parse_periods(words)
    if len(periods) > 1:
        raise ValueError('too many periods')
    return abo.balance.Range(periods[0][0], periods[0][1] + datetime.timedelta(1))

def filter_period(chart, transactions, opts):
    brought_forward = None
    if opts['<period>']:
        range = parse_range(opts['<period>'])
        if range.start is not None:
            brought_forward = abo.balance.Balance(transactions, abo.balance.Range(None, range.start), chart=chart)
        transactions = [t for t in transactions if t.date in range]
    else:
        range = abo.balance.Range(None, None)
    return range, brought_forward, transactions

def filter_at(chart, transactions, opts):
    when = abo.period.parse_when(opts['<when>']) if opts['<when>'] else datetime.date.today()
    range = abo.balance.Range(None, when + datetime.timedelta(1))
    balance = abo.balance.Balance(transactions, range, chart=chart)
    transactions = [t for t in transactions if t.date in range]
    return when, balance, transactions

def range_line(range):
    p = []
    if range.start is not None:
        p.append('FROM')
        p.append(range.start.strftime(ur'%_d-%b-%Y'))
    if range.end is not None:
        p.append('TO')
        p.append(range.last.strftime(ur'%_d-%b-%Y'))
    return ' '.join(p) if p else 'ALL DATES'

class InvalidArg(ValueError):
    pass

def fatal(message, status=1):
    print >>sys.stderr, "%s: %s" % (os.path.basename(sys.argv[0]), message)
    sys.exit(status)

if __name__ == '__main__':
    main()
