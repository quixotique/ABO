#!/usr/bin/env python2.7
# vim: sw=4 sts=4 et fileencoding=utf8 nomod
# Copyright 2013 Andrew Bettison

'''Usage:
    pyabo chart [-f] [AL|PL|EQ]
    pyabo acc [-fw] <account> [<period>...]
    pyabo journal [-fw] [<period>...]
    pyabo balance [-fa] [<when>...]
    pyabo -h | --help
    pyabo --version
Options:
    -h --help               Show this message
    --version               Show version and exit
    -f --force              Force re-population of transaction cache
    -w --wrap               Wrap long lines
    -a --all                Show all accounts
'''

import sys
import locale
import codecs
import os.path
import textwrap
import datetime
from itertools import chain

try:
    import docopt
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), '..', 'lib', 'docopt'))
    import docopt

try:
    import abo.journal
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), '..', 'lib'))
    import abo.journal
import abo.config
import abo.period
import abo.balance
import abo.cache

def main():
    locale.setlocale(locale.LC_ALL, '')
    lang, enc = locale.getlocale()
    output_encoding = enc
    opts = docopt.docopt(__doc__, version='0.1')
    if opts['acc']:
        func = cmd_acc
    elif opts['journal']:
        func = cmd_journal
    elif opts['chart']:
        func = cmd_chart
    elif opts['balance']:
        func = cmd_balance
    else:
        assert False, 'unknown command'
    config = abo.config.config()
    try:
        for line in func(config, opts):
            print line.encode(output_encoding)
    except InvalidArg, e:
        print unicode(e).encode(output_encoding)
        sys.exit(1)
    sys.exit(0)

def get_chart(config, opts):
    return abo.cache.FileCache(config.chart_file_path, lambda: abo.account.Chart.from_file(file(config.chart_file_path))).get(force=opts['--force'])

def get_transactions(config, opts):
    chart = get_chart(config, opts)
    caches = []
    for path in config.input_file_paths:
        caches.append(abo.cache.TransactionCache(path, abo.journal.Journal(file(path), chart=chart)))
    transactions = []
    for cache in caches:
        transactions += cache.transactions(force=opts['--force'])
    transactions.sort(key=lambda t: (t.date, t.who or '', t.what or '', -t.amount()))
    return transactions

def cmd_journal(config, opts):
    range, bf, transactions = filter_period(get_transactions(config, opts), opts)
    width = max(50, config.output_width())
    aw = 15
    dw = 11
    bw = config.balance_column_width()
    pw = max(1, width - dw - 2 - 1 - aw - 1 - bw - 1 - 2)
    fmt = u'%-{dw}.{dw}s  %-{pw}.{pw}s %{bw}s %-2.2s %-{aw}.{aw}s'.format(**locals())
    yield 'JOURNAL OF TRANSACTIONS'.center(width)
    yield range_line(range).center(width)
    yield ''
    yield fmt % ('Date', 'Particulars', 'Amount', 'DC', 'Account')
    yield fmt % ('-' * dw, '-' * pw, '-' * bw, '--', '-' * aw)
    def entry_fields(e):
        return (config.format_money(abs(e.amount)), ('db' if e.amount < 0 else 'cr'), e.account.label)
    if bf:
        for e in bf.entries():
            yield fmt % (('',
                'Brought forward' + (' due ' + e.cdate.strftime(ur'%-d-%b-%Y') if e.cdate else ''),)
                + entry_fields(e))
    for t in transactions:
        desc = textwrap.wrap(t.description(), width=pw)
        entries = list(t.entries)
        yield fmt % ((t.date.strftime(ur'%_d-%b-%Y'), desc.pop(0)) + entry_fields(entries.pop(0)))
        while entries:
            yield fmt % (('', desc.pop(0) if desc else u'') + (entry_fields(entries.pop(0)) if entries else ('', '', '')))
        if opts['--wrap']:
            while desc:
                yield fmt % ('', desc.pop(0), '', '', '')
    yield fmt % ('-' * dw, '-' * pw, '-' * bw, '--', '-' * aw)

def cmd_chart(config, opts):
    typesel = (opts['AL'] or '').upper()
    if typesel == 'AL':
        pred = lambda a: a.atype == abo.account.AccountType.AssetLiability
    elif typesel == 'PL':
        pred = lambda a: a.atype == abo.account.AccountType.ProfitLoss
    elif typesel == 'EQ':
        pred = lambda a: a.atype == abo.account.AccountType.Equity
    elif typesel == '':
        pred = lambda a: True
    else:
        raise InvalidArg('invalid argument: %r' % (opts['AL'],))
    for account in get_chart(config, opts).accounts():
        if pred(account):
            yield unicode(account)

def cmd_acc(config, opts):
    chart = get_chart(config, opts)
    account = chart.account(opts['<account>'])
    range, bf, transactions = filter_period(get_transactions(config, opts), opts)
    width = max(50, config.output_width())
    dw = 11
    mw = config.money_column_width()
    bw = config.balance_column_width()
    pw = max(1, width - dw - 2 - 2 * (mw + 1) - 1 - bw)
    fmt = u'%-{dw}.{dw}s  %-{pw}.{pw}s %{mw}s %{mw}s %{bw}s'.format(**locals())
    yield 'STATEMENT OF ACCOUNT'.center(width)
    yield range_line(range).center(width)
    yield ''
    yield fmt % ('Date', 'Particulars', 'Debit', 'Credit', 'Balance')
    yield fmt % ('-' * dw, '-' * pw, '-' * mw, '-' * mw, '-' * bw)
    balance = 0
    totdb = 0
    totcr = 0
    if bf:
        for e in bf.entries():
            if e.account in account:
                balance += e.amount
                yield fmt % ('', 'Brought forward' + (' due ' + e.cdate.strftime(ur'%-d-%b-%Y') if e.cdate else ''),
                        config.format_money(-e.amount) if e.amount < 0 else '',
                        config.format_money(e.amount) if e.amount > 0 else '',
                        config.format_money(balance))
    for t in transactions:
        for e in t.entries:
            if e.account in account:
                balance += e.amount
                if e.amount < 0:
                    totdb += e.amount
                elif e.amount > 0:
                    totcr += e.amount
                desc = textwrap.wrap(e.description(), width=pw)
                yield fmt % (e.transaction.date.strftime(ur'%_d-%b-%Y'),
                        desc.pop(0),
                        config.format_money(-e.amount) if e.amount < 0 else '',
                        config.format_money(e.amount) if e.amount > 0 else '',
                        config.format_money(balance))
                if opts['--wrap']:
                    while desc:
                        yield fmt % ('', desc.pop(0), '', '', '')
    yield fmt % ('-' * dw, '-' * pw, '-' * mw, '-' * mw, '-' * bw)
    yield fmt % ('', 'Totals for period',
            config.format_money(-totdb),
            config.format_money(totcr),
            '')
    yield fmt % ('', 'Balance', '', '', config.format_money(balance))

def cmd_balance(config, opts):
    chart = get_chart(config, opts)
    all_transactions = get_transactions(config, opts)
    when, balance, transactions = filter_at(all_transactions, opts)
    bw = config.balance_column_width()
    aw = max(len(unicode(a)) for a in chart.accounts())
    width = max(bw + 2 + aw, config.output_width())
    fmt = u'%{bw}s  %s'.format(**locals())
    yield 'ACCOUNT BALANCES'.center(width)
    yield when.strftime(ur'%_d-%b-%Y').center(width)
    yield ''
    yield fmt % ('Balance', 'Account')
    yield fmt % ('-' * bw, '-' * aw)
    for account in balance.accounts:
        bal = balance.balance(account)
        if bal or opts['--all']:
            yield fmt % (config.format_money(bal), unicode(account))
    yield fmt % ('-' * bw, '-' * aw)

def parse_range(words):
    periods = abo.period.parse_periods(words)
    if len(periods) > 1:
        raise ValueError('too many periods')
    return abo.balance.Range(*periods[0])

def filter_period(transactions, opts):
    brought_forward = None
    if opts['<period>']:
        range = parse_range(opts['<period>'])
        if range.start is not None:
            brought_forward = abo.balance.Balance(transactions, abo.balance.Range(None, range.start))
        transactions = [t for t in transactions if t.date in range]
    else:
        range = abo.balance.Range(None, None)
    return range, brought_forward, transactions

def filter_at(transactions, opts):
    if opts['<when>']:
        when = abo.period.parse_when(opts['<when>'])
        range = abo.balance.Range(None, when + datetime.timedelta(1))
        balance = abo.balance.Balance(transactions, range)
        transactions = [t for t in transactions if t.date in range]
    return when, balance, transactions

def range_line(range):
    p = []
    if range.start is not None:
        p.append('FROM')
        p.append(range.start.strftime(ur'%_d-%b-%Y'))
    if range.end is not None:
        p.append('TO')
        p.append(range.end.strftime(ur'%_d-%b-%Y'))
    return ' '.join(p) if p else 'ALL DATES'

class InvalidArg(ValueError):
    pass

if __name__ == '__main__':
    main()
